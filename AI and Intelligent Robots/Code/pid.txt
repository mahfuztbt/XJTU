#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include "nav_msgs/Odometry.h"
#include "sensor_msgs/LaserScan.h"
#include <fstream>
#include <time.h>
#include <iomanip>
#include <iostream>
#include <cmath>
#include <chrono>


using namespace std;
using namespace std::chrono;
	
	struct EulerAngles{
	double roll, pitch, yaw; // yaw is what you want, i.e. Th
}; 
	
	struct Quaternion{
	double w, x, y, z;
};

	EulerAngles ToEulerAngles(Quaternion q) {
	EulerAngles angles;
	// roll (x-axis rotation)
	double sinr_cosp = +2.0 * (q.w * q.x + q.y * q.z);
	double cosr_cosp = +1.0 - 2.0 * (q.x * q.x + q.y * q.y);
	angles.roll = atan2(sinr_cosp, cosr_cosp);
	// pitch (y-axis rotation)
	double sinp = +2.0 * (q.w * q.y - q.z * q.x);
	if (fabs(sinp) >= 1)
	    angles.pitch = copysign(M_PI/2, sinp); //use 90 degrees if out of range
	else
	    angles.pitch = asin(sinp);
	// yaw (z-axis rotation)
	double siny_cosp = +2.0 * (q.w * q.z + q.x * q.y);
	double cosy_cosp = +1.0 - 2.0 * (q.y * q.y + q.z * q.z);
	angles.yaw = atan2(siny_cosp, cosy_cosp);
	return angles;
}

class RobotMove { //main class
public:
	// Tunable parameters
	static constexpr const double FORWARD_SPEED_LOW = 0.1;
	static constexpr const double FORWARD_SPEED_MIDDLE = 0.3;
	static constexpr const double FORWARD_SPEED_HIGH = 0.5;
	static constexpr const double FORWARD_SPEED_STOP = 0;
	static constexpr const double TURN_LEFT_SPEED_HIGH = 1.0;
	static constexpr const double TURN_LEFT_SPEED_MIDDLE = 0.6;
	static constexpr const double TURN_LEFT_SPEED_LOW = 0.3;
	static constexpr const double TURN_RIGHT_SPEED_HIGH = -1.0;
	static constexpr const double TURN_RIGHT_SPEED_MIDDLE = -0.6;
	static constexpr const double TURN_RIGHT_SPEED_LOW = -0.3;
	
	RobotMove();
	void startMoving();
	void moveForward(double forwardSpeed);
	void moveStop();
	void moveRight(double turn_right_speed);
	void moveForwardRight(double forwardSpeed, double turn_right_speed);
	void odomCallback(const	nav_msgs::Odometry::ConstPtr& odomMsg);
	void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan);
	void transformMapPoint(ofstream& fp, double laserRange, double laserTh);
	void PID_wallFollowing(double moveSpeed, double laserData);
	void PID_to1stGap(double moveSpeed, double robotHeading);
	void PID_to2ndGap(double moveSpeed, double robotHeading);
	void PID_wall2Following(double moveSpeed, double laserData);
	void PID_toS(double FORWARD_SPEED_MIDDLE, double robotHeadAngle);

private:
	ros::NodeHandle node;
	ros::Publisher commandPub; // Publisher to the robots
	ros::Subscriber odomSub; //Subscriber to robots odometry topic
	ros::Subscriber laserSub; // Subscriber to robot’s laser topic
	
	double homeX = 0.3, homeY = 0.3;	
	double PositionX = 0.3, PositionY = 0.3, //current position
	landmark1 = 1.15, landmark2 = 0.9; // Landmarks for navigation
	double landmark3 = 1.2, landmark4 = 1.4, landmark5 = 1.6, landmark6=1.95, landmark7=2.3;
	double robVelocity=0; 
	double frontRange=0; double mleftRange=0; double leftRange=0; double rightRange=0; double mrightRange=0;
	double backRange=0; double backleftRange=0; double backrightRange=0; double laserData[36];
	double frontAngle=0; double mleftAngle=M_PI/4; double leftAngle=M_PI/2;
	double rightAngle=-M_PI/2; double mrightAngle=-M_PI/4;
	double backAngle=M_PI; double backleftAngle=3*M_PI/4; double backrightAngle=-3*M_PI/4;
	double kp1 = 0.07, ki1 = 0.007, kd1 = 0.001;
	double ei_pre1 = 0; 
	double ed_pre1 = 0;
	double landmark1_toWall = 0.3, Max_PID_outout = 0.6; double landmark2_toWall = 0.07;	
	
	// new PID variables for going through the 1st gap	
	double kp2=0.5, ki2=0.02, kd2=0.001, ei_pre2 = 0;
	double ed_pre2 = 0, landmark2_heading=0;
	// new PID variables for going through the 2nd gap	
	double kp3=50, ki3=2, kd3=0.5, ei_pre3 = 0;
	double ed_pre3 = 0, landmark3_heading=-.77;
	// new PID variables for going to S	
	double kp4=50, ki4=2, kd4=0.5, ei_pre4 = 0;
	double ed_pre4 = 0, landmark4_heading=-1.18;
	Quaternion robotQuat;
	EulerAngles robotAngles;
	double robotHeadAngle;
};

	
	// function to open files for data storage
	ofstream openFile(const string& name){  
	string homedir = getenv("HOME"); 
	ostringstream path; 
	path << homedir << "/ros_workspace/src/tutorial_pkg/" << name; 
	return ofstream(path.str());
}	
	 ros::Time current_time;
	 ros::Duration real_time;
      

	

	RobotMove::RobotMove(){
	//Advertise a new publisher for the simulated robots velocity command topic at 10Hz
	commandPub = node.advertise<geometry_msgs::Twist>("cmd_vel", 10);
	// subscribe to the odom topic
	odomSub = node.subscribe("odom", 20, &RobotMove::odomCallback, this);
	laserSub = node.subscribe("scan", 1, &RobotMove::scanCallback, this);
}


	//send a velocity command not heree check it 
	void RobotMove::moveForward(double forwardSpeed){
	geometry_msgs::Twist msg;//The default constructor to set all commands to 0
	msg.linear.x = forwardSpeed; //Drive forward at a given speed along the x-axis.
	commandPub.publish(msg);
}


	void RobotMove::moveStop(){
	geometry_msgs::Twist msg;
	msg.linear.x = FORWARD_SPEED_STOP;
	commandPub.publish(msg);
}


	void RobotMove::moveRight(double turn_right_speed){
	geometry_msgs::Twist msg;
	msg.angular.z = turn_right_speed;
	commandPub.publish(msg);
}

	// add the following code
	void RobotMove::moveForwardRight(double forwardSpeed, double turn_right_speed){
	//move forward and right at the same time
	geometry_msgs::Twist msg; 
	msg.linear.x = forwardSpeed; 
	msg.angular.z = turn_right_speed;
	commandPub.publish(msg);
}

	//  callback function to determine the robot position.
	void RobotMove::odomCallback(const nav_msgs::Odometry::ConstPtr& odomMsg){
	PositionX = odomMsg->pose.pose.position.x + homeX;
	PositionY = odomMsg->pose.pose.position.y + homeY;
	robotQuat.x = odomMsg->pose.pose.orientation.x;
	robotQuat.y = odomMsg->pose.pose.orientation.y;
	robotQuat.z = odomMsg->pose.pose.orientation.z;
	robotQuat.w = odomMsg->pose.pose.orientation.w;
	robotAngles = ToEulerAngles(robotQuat);
	robotHeadAngle = robotAngles.yaw;

}
	//  callback function to collect laser scan data.
	void RobotMove::scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan){
	// collect 36 laser readings every 360 degrees scan
	for(int i=0; i<36; i++) // to get 36 laser readings over 360 degrees
	    laserData[i] = scan->ranges[i*10]; // to get laser readings every 10 degrees
	
	// the following code for the control purpose
	frontRange = scan->ranges[0]; // get the range reading at 0 radians
	mleftRange = scan->ranges[89]; // get the range reading at -π/4 radians
	leftRange = scan->ranges[179]; // get the range reading at -π/2 radians
	rightRange = scan->ranges[539]; // get the range reading at π/2 radians
	mrightRange = scan->ranges[629]; // get the range reading at π/4 radians
	backRange = scan->ranges[359]; // get the range reading at π radians
	backleftRange = scan->ranges[269]; // get the range reading at π/2 radians
	backrightRange = scan->ranges[449]; // get the range reading at π/4 radians
}

	void RobotMove::transformMapPoint(ofstream& fp, double laserRange, double laserTh){
	double localX, localY, globalX, globalY;
	localX = laserRange * cos(laserTh);
	localY = laserRange * sin(laserTh);
	globalX =(localX*cos(robotHeadAngle)-localY*sin(robotHeadAngle))+ PositionX;
	globalY = (localX*sin(robotHeadAngle)+localY*cos(robotHeadAngle))+ PositionY;
	if (globalX < 0) globalX = 0; else if (globalX > 2.5) globalX = 2.5;
	if (globalY < 0) globalY = 0; else if (globalY > 2.5) globalY = 2.5;
	fp << globalX << " " << globalY << endl;
}
	void RobotMove::PID_wallFollowing(double moveSpeed, double laserData){
		double ei,ed,err,output;
		err = laserData - landmark1_toWall;
		ei = ei_pre1 + err;
		ed = err - ed_pre1;
		double ei_pre1 = ei; 
		double ed_pre1 = ed;
		output = kp1*err + ki1*ei + kd1*ed;
	if (output > Max_PID_outout )
	    output = Max_PID_outout;
	else if(output < -Max_PID_outout)
	        output = -Max_PID_outout;

	geometry_msgs::Twist msg;
	msg.linear.x = moveSpeed;
	msg.angular.z = output;
	commandPub.publish(msg);
}

void RobotMove::PID_wall2Following(double moveSpeed, double laserData){
		double ei,ed,err,output;
		err = laserData - landmark2_toWall;
		ei = ei_pre2 + err;
		ed = err - ed_pre2;
		double ei_pre2 = ei; 
		double ed_pre2 = ed;
		output = kp2*err + ki2*ei + kd2*ed;
	if (output > Max_PID_outout )
	    output = Max_PID_outout;
	else if(output < -Max_PID_outout)
	        output = -Max_PID_outout;

	geometry_msgs::Twist msg;
	msg.linear.x = moveSpeed;
	msg.angular.z = output;
	commandPub.publish(msg);
}
	void RobotMove::PID_to1stGap(double moveSpeed, double robotHeading){
		double ei,ed,err,output;
		err = landmark2_heading-robotHeading;
		ei = ei_pre2 + err;
		ed = err - ed_pre2;
		ei_pre2 = ei;
		ed_pre2 = ed;
		output = kp2*err + ki2*ei + kd2*ed;
	if (output > Max_PID_outout )
		output = Max_PID_outout;
	else if(output < -Max_PID_outout)
		output = -Max_PID_outout;
	
	geometry_msgs::Twist msg;
	msg.linear.x = moveSpeed;
	msg.angular.z = output;
	commandPub.publish(msg);
}

	void RobotMove::PID_to2ndGap(double moveSpeed, double robotHeading){
		double ei,ed,err,output;
		err = landmark3_heading-robotHeading;
		ei = ei_pre3 + err;
		ed = err - ed_pre3;
		ei_pre3 = ei;
		ed_pre3 = ed;
		output = kp3*err + ki3*ei + kd3*ed;
	if (output > Max_PID_outout )
		output = Max_PID_outout;
	else if(output < -Max_PID_outout)
		output = -Max_PID_outout;
	
	geometry_msgs::Twist msg;
	msg.linear.x = moveSpeed;
	msg.angular.z = output;
	commandPub.publish(msg);

}

	void RobotMove::PID_toS(double moveSpeed, double robotHeading){
		double ei,ed,err,output;
		err = landmark4_heading-robotHeading;
		ei = ei_pre4 + err;
		ed = err - ed_pre4;
		ei_pre4 = ei;
		ed_pre4 = ed;
		output = kp4*err + ki4*ei + kd4*ed;
	if (output > Max_PID_outout )
		output = Max_PID_outout;
	else if(output < -Max_PID_outout)
		output = -Max_PID_outout;

	
	geometry_msgs::Twist msg;
	msg.linear.x = moveSpeed;
	msg.angular.z = output;
	commandPub.publish(msg);
}
	// Function to start moving 
	void RobotMove::startMoving(){
	int stage = 1;
	ofstream odomTrajFile = openFile("odomTrajData.csv");
	ofstream odomVelFile = openFile("odomVelData.csv");
	ofstream laserFile = openFile("laserData.csv");	
	ofstream laserMapFile = openFile("laserMapData.csv");
	ros::Rate rate(20); //Define rate for repeatable operations.
	ROS_INFO("Start moving");
	auto currentTime = high_resolution_clock::now();
	auto startTime = currentTime;

	while (ros::ok()){ // keep spinning loop until user presses Ctrl+C
	   switch(stage){
	      case 1: // wall-following 


			if (PositionY < landmark1)  // create “the PID-based wall following behaviour”
			PID_wallFollowing(FORWARD_SPEED_HIGH, leftRange);
		else stage = 2;; // switch to next state if the condition meets
		 break; 

	      case 2: // move toward the middle of the 1 st gap
		  if (PositionX < landmark2) // create “PID-based going through the 1 st gap behaviour”
		      PID_to1stGap(FORWARD_SPEED_MIDDLE, robotHeadAngle);
		else stage = 3;
		break;
	      case 3: // the robot moves forward fast
		  if (PositionX < landmark3)  // create “PID-based moving toward the 2 nd gap behaviour”
			PID_wall2Following(FORWARD_SPEED_HIGH, leftRange);  
	          else
		     stage = 4;
		  break;
	      case 4: // the robot moves and turns right slowly
		  if (PositionX < landmark4) // create “PID-based going through the 2 nd gap behaviour”
		      PID_to2ndGap(FORWARD_SPEED_MIDDLE, robotHeadAngle);
	  	  else
		     stage = 5;
		  break;
	      case 5: // the robot moves towards the charger
		
		   if (PositionX < landmark5 ){ // create “PID-based reaching goal behaviour” 
 	      	       PID_to2ndGap(FORWARD_SPEED_MIDDLE, robotHeadAngle);	
}		
		    else if (PositionX<landmark6){
		      moveForward(FORWARD_SPEED_HIGH); 
}
		    else
  		      stage = 6;
		  break;
	      case 6: // stop at the charger position
                   if (PositionX<landmark7) 
			PID_toS(FORWARD_SPEED_MIDDLE, robotHeadAngle);
		    else
		      stage = 7;
 		break;
	      case 7: // stop at the charger position
		     moveStop();
		break;
        }

		auto currentTime = high_resolution_clock::now();
		duration<double, std::deca> runTime = currentTime - startTime;
		runTime *= 10; // convert time to seconds
		odomVelFile << ceil(runTime.count()) << " " << robVelocity << endl;
		odomTrajFile << PositionX << " " << PositionY << endl;
	for(int i=0; i<36; i++) // save laser data for view and check
	laserFile << i << " " << laserData[i];
	laserFile << endl;
	transformMapPoint(laserMapFile, frontRange, frontAngle);
	transformMapPoint(laserMapFile, leftRange, leftAngle);
	transformMapPoint(laserMapFile, rightRange, rightAngle);
	transformMapPoint(laserMapFile, mleftRange, mleftAngle);
	transformMapPoint(laserMapFile, mrightRange, mrightAngle);	
	
	ros::spinOnce(); // Allow ROS to process incoming messages
	rate.sleep(); // Wait until defined time passes.
    }
	odomTrajFile.close();	   
	odomVelFile.close();
	laserFile.close();	
	laserMapFile.close();
	ROS_INFO("Closing files");
}
	int main(int argc, char **argv) {
	ros::init(argc, argv, "RobotMove");//Initiate new ROS node named "RobotMove"
	RobotMove RobotMove;              // Create new RobotMove object
	RobotMove.startMoving();	 // Start the movement
	return 0;
}
