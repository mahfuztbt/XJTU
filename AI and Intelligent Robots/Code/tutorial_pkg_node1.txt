#include "ros/ros.h"
#include "geometry_msgs/Twist.h"

class RobotMove {
public:
    // Tunable parameters
    constexpr static double FORWARD_SPEED_LOW = 0.1;
    constexpr static double FORWARD_SPEED_HIGH = 0.2;
    constexpr static double FORWARD_SPEED_SHIGH = 0.4;
    constexpr static double FORWARD_SPEED_STOP = 0;
    constexpr static double TURN_LEFT_SPEED_HIGH = 1.0;
    constexpr static double TURN_LEFT_SPEED_LOW = 0.3;
    constexpr static double TURN_RIGHT_SPEED_HIGH = -2.4;
    constexpr static double TURN_RIGHT_SPEED_LOW = -0.3;
    constexpr static double TURN_RIGHT_SPEED_MIDDLE = -0.6;

    RobotMove();
    void startMoving();
    void moveForward(double forwardSpeed);
    void moveStop();
    void moveRight(double turn_right_speed = TURN_RIGHT_SPEED_HIGH);
    void moveForwardRight(double forwardSpeed, double turn_right_speed);

private:
    ros::NodeHandle node;
    ros::Publisher commandPub; // Publisher to the robot's velocity command topic
};

RobotMove::RobotMove() : node() {
    // Advertise a new publisher for the simulated robot's velocity command topic at 10Hz
    commandPub = node.advertise<geometry_msgs::Twist>("cmd_vel", 10);
}

// Send a velocity command
void RobotMove::moveForward(double forwardSpeed) {
    geometry_msgs::Twist msg; // The default constructor sets all commands to 0
    msg.linear.x = forwardSpeed; // Drive forward at a given speed along the x-axis
    commandPub.publish(msg);
}

void RobotMove::moveStop() {
    geometry_msgs::Twist msg;
    msg.linear.x = FORWARD_SPEED_STOP;
    commandPub.publish(msg);
}

void RobotMove::moveRight(double turn_right_speed) {
    geometry_msgs::Twist msg;
    msg.angular.z = turn_right_speed; // Set the angular velocity for turning right
    commandPub.publish(msg);
}

void RobotMove::moveForwardRight(double forwardSpeed, double turn_right_speed) {
    geometry_msgs::Twist msg;
    msg.linear.x = forwardSpeed;
    msg.angular.z = turn_right_speed; 
    commandPub.publish(msg);
}

void RobotMove::startMoving() {
    ros::Rate rate(20); // Define rate for repeatable operations
    ROS_INFO("Start moving");

    while (ros::ok()) {
        moveForward(FORWARD_SPEED_LOW);
        ROS_INFO_STREAM("Robot speed: " << FORWARD_SPEED_LOW);
        ros::spinOnce(); // Allow ROS to process incoming messages
        rate.sleep(); // Wait until defined time passes
    }
}

int main(int argc, char **argv) {
    ros::init(argc, argv, "RobotMove"); // Initiate new ROS node named "RobotMove"
    RobotMove robotMove; // Create new RobotMove object
    robotMove.startMoving(); // Start the movement
    return 0;
}
